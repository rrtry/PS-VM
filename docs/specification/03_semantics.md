# Семантика языка

## 1. Система типов
### 1.1. Встроенные типы

| Тип | Описание | Значения |
|-----|----------|----------|
| `int`   | 64-битное знаковое целое | −9 223 372 036 854 775 808 … 9 223 372 036 854 775 807         |
| `float` | 64-битное число с плавающей точкой (IEEE 754 binary64) | Приближённо 1.8 * 10 ^ 308       |
| `str`   | Неизменяемая Unicode-строка, внутреннее представление UTF-8 | Последовательность символов |

### 1.2. Логический тип
bool. Возможные значения: true/false. Используется в логических контекстах (условия `if`, `while`, `for`, операнды `&&`, `||`, `!`)

### 1.3. Преобразования типов

**Неявные преобразования** (автоматические):
- `int -> float` в арифметических операциях, если второй операнд `float`

**Явные преобразования** (через встроенные функции):

| Функция | Преобразование |
|---------|----------------|
| `itos(i: int): str`                           | Целое -> строка |
| `ftos(f: float, p: int): str`                 | Число с плавающей точкой -> строка с `p` знаков после запятой |
| `itof(i: int): float`                         | Целое -> число с плавающей точкой |
| `ftoi(f: float): int`                         | Число с плавающей точкой -> целое (отбрасывание дробной части) |
| `stoi(s: str): int`                           | Строка -> целое |
| `stof(s: str): float`                         | Строка -> число с плавающей точкой |
| `sconcat(s1: str, s2: str): str`              | Конкатенация строк |
| `substr(s: str, from: int, length: int): str` | Извлечение подстроки |
| `strlen(s: str): int`                         | Длина строки в символах |

## 2. Семантика выражений
### 2.1. Арифметические операторы (`+`, `-`, `*`, `/`, `%`, `**`)

**Правила приведения типов:**
- Если оба операнда `int` → результат `int`
- Если хотя бы один операнд `float` → второй приводится к `float`, результат `float`

**Особенности:**
- Оператор `%` допустим для обоих типов
- Оператор `**` — возведение в степень, правоассоциативен
- Деление на ноль — ошибка времени выполнения

### 2.2. Операторы сравнения (`<`, `>`, `<=`, `>=`, `==`, `!=`)

| Типы операндов | Результат | Ограничения |
|----------------|-----------|-------------|
| `int` с `int`     | `1` (истина) или `0` (ложь) | — |
| `float` с `float` | `1` (истина) или `0` (ложь) | Сравнение IEEE 754 |
| `str` с `str`     | `1` (истина) или `0` (ложь) | Только `==` и `!=`, посимвольное сравнение Unicode |
| `bool` c `bool`   | `1` (истина) или `0` (ложь) | Только `==` и `!=`
| Разные типы | — | Ошибка проверки типов |

### 2.3. Логические операторы (`&&`, `||`, `!`)

- Операнды приводятся к истине/лжи по правилам п.1.2
- Результат: `true` (истина) или `false` (ложь) типа `bool`
- `&&` и `||` используют **короткозамкнутые вычисления** (short-circuit evaluation):
  - `a && b`: если `a` ложно, `b` не вычисляется
  - `a || b`: если `a` истинно, `b` не вычисляется

### 2.4. Вызов функций

- Аргументы вычисляются **слева направо**
- Количество аргументов должно совпадать с количеством параметров
- Типы аргументов должны совпадать с типами параметров (с учётом неявных преобразований)

### 2.5. Присваивание

- Левая часть — только идентификатор переменной
- Тип выражения должен соответствовать типу переменной (с учётом неявных преобразований)
- Присваивание само является выражением и возвращает присвоенное значение

## 3. Семантика инструкций

### 3.1. Объявление переменной

- Переменная должна быть объявлена до использования
- Повторное объявление в той же области видимости запрещено
- Если тип указан явно, выражение должно иметь совместимый тип
- Если тип не указан, он выводится из выражения
- Все переменные изменяемы (mutable)
- Использование неинициализированной переменной — ошибка

### 3.2. Ветвление if-else

- Условие вычисляется, приводится к логическому значению
- При истине выполняется блок после `if`, иначе — блок после `else` (если есть)
- Проблема "висячего else" разрешается привязкой `else` к ближайшему предшествующему `if`
- `if` — инструкция, не возвращает значение

### 3.3. Цикл while

- Условие проверяется перед каждой итерацией
- Тело выполняется, пока условие истинно
- while — инструкция, не возвращает значение

### 3.4. Цикл for

Эквивалентен следующей конструкции:

<инициализация>;
while (<условие>) {
<тело>
<обновление>;
}


- Инициализация выполняется один раз входа в цикл
- Условие проверяется перед каждой итерацией
- Обновление выполняется после тела каждой итерации

### 3.5. break и continue

- `break` - немедленный выход из ближайшего цикла (`while` или `for`)
- `continue` - переход к следующей итерации ближайшего цикла (для `for` сначала выполняется обновление)
- Использование вне цикла - ошибка

### 3.6. return

- Для функций с типом `unit`: `return;` завершает выполнение функции (неявный `return` в конце тела)
- Для остальных типов: `return <выражение>;` обязательно на всех путях выполнения
- Тип выражения должен соответствовать возвращаемому типу функции

## 4. Области видимости

- Лексическая (статическая) область видимости
- Новые области создаются:
  - Телом функции `{ ... }`
  - Блоками внутри функций (составные инструкции)
- Переменные и функции находятся в **разных пространствах имён**:
  - Можно иметь функцию `max` и переменную `max` в одной области
  - Переменная не может быть объявлена с именем ключевого слова
- Вложенные блоки видят переменные внешних блоков
- Внутренний блок может перекрывать имя переменной внешнего блока (shadowing) - разрешено

## 5. Функции
### 5.1. Объявление и вызов

- Функции должны быть объявлены на верхнем уровне (не внутри других функций)
- Порядок объявления не важен — все функции видны во всей программе
- Параметры передаются **по значению** (копирование)
- Формальные параметры — локальные переменные функции
- Рекурсия поддерживается
- Замыкания (захват переменных внешней функции) **не поддерживаются**

### 5.2. Точка входа

- Обязательна функция `fn main() { ... }`
- Без параметров, без возвращаемого типа (эквивалент `unit`)
- Выполнение программы начинается с `main`
- Код возврата операционной системе — всегда `0`

## 6. Встроенные функции ввода/вывода

| Функция | Описание |
|---------|----------|
| `input(): str`     | Читает строку из стандартного ввода |
| `print(x: int)`    | Выводит целое число в стандартный вывод |
| `print(s: str)`    | Выводит строку в стандартный вывод |
| `printf(f: float)` | Выводит вещественное число в стандартный вывод |
| `printi(i: int)`   | Выводит целое число в стандартный вывод |

## 7. Семантические ограничения

| Ограничение | Пример нарушения | Пояснение |
|-------------|------------------|-----------|
| Использование необъявленной переменной | `x = 10;` (без `let x`) | Ошибка компиляции |
| Повторное объявление в одной области   | `let x = 1; let x = 2;` | Ошибка компиляции |
| Несоответствие типов при присваивании  | `let x: int = "hello";` | Ошибка компиляции |
| Несоответствие типов в операциях | `"hello" + 42` | Ошибка компиляции |
| Отсутствие `return` в функции не-unit | `fn foo(): int { }` | Ошибка компиляции |
| `break/continue` вне цикла | `if (x) { break; }` | Ошибка компиляции |
| Выражение как инструкция без эффекта | `x + 5;` | Ошибка компиляции |
| Использование ключевого слова как идентификатора | `let if = 10;` | Ошибка компиляции |
| Вызов функции с неверным количеством аргументов | `fn f(a: int) {}; f(1, 2);` | Ошибка компиляции |
| Вызов функции `unit` в выражении | `let x = printi(5);` | Ошибка компиляции |