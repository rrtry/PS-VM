# Лексическая структура языка

## 1. Ключевые слова

Ключевые слова зарезервированы и не могут использоваться в качестве идентификаторов. Регистрозависимы.
| Ключевое слово | Назначение |
|----------------|------------|
| `fn`       | Определение функции |
| `let`      | Объявление переменной |
| `return`   | Возврат значения из функции |
| `if`       | Условный оператор |
| `else`     | Альтернативная ветка условного оператора |
| `while`    | Цикл с предусловием |
| `for`      | Цикл со счётчиком |
| `break`    | Прерывание цикла |
| `continue` | Переход к следующей итерации цикла |
| `int`      | Объявление целочисленного типа |
| `float`    | Объявление типа с плавающей точкой |
| `str`      | Объявление строкового типа |
| `bool`     | Объвление логического типа | 
| `unit`     | Тип, означающий отсутствие возвращаемого значения |

## 2. Идентификаторы

**Идентификаторы** — имена переменных, функций и параметров.

Правила формирования:
- Допустимые символы: латинские буквы (`A-Z`, `a-z`), цифры (`0-9`), символ подчёркивания (`_`)
- Первый символ: буква или символ подчёркивания
- Регистрозависимы: `count` ≠ `Count` ≠ `COUNT`
- Не могут совпадать с ключевыми словами

**Примеры допустимых идентификаторов:**

counter
_value
temp1
calculateSum

**Недопустимые идентификаторы:**

1value (начинается с цифры)
let (ключевое слово)

## 3. Литералы

### 3.1. Числовые литералы

**Целочисленные литералы** (тип `int`):
- Десятичные: последовательность цифр `0-9` (например, `42`, `0`, `100500`)
- Шестнадцатеричные: префикс `0x` или `0X`, затем цифры `0-9`, `A-F`, `a-f` (например, `0x2A`, `0Xff`)
- Двоичные: последовательность цифр `0-1` (например, `0101010`)

**Литералы с плавающей точкой** (тип `float`):
- Формат: целая часть, точка, дробная часть (например, `3.14`, `0.5`, `-12.75`)
- Обязательно наличие хотя бы одной цифры с каждой стороны точки

Отрицательные числа формируются применением унарного оператора `-` к литералу.

### 3.2. Строковые литералы

- Обрамляются двойными кавычками: `"..."`
- Поддерживают Unicode, хранятся в UTF-8
- Поддерживают экранированные последовательности:

| Последовательность | Значение |
|--------------------|----------|
| `\n` | Перевод строки (LF) |
| `\t` | Табуляция |
| `\\` | Обратная косая черта |
| `\"` | Двойная кавычка |


## 4. Операторы и знаки пунктуации

| Лексема | Название | Применение |
|---------|----------|------------|
| `+`    | Плюс | Сложение, унарный плюс |
| `-`    | Минус | Вычитание, унарный минус |
| `*`    | Звёздочка | Умножение |
| `/`    | Слеш | Деление |
| `%`    | Процент | Остаток от деления |
| `**`   | Возведение в степень |
| `=`    | Равно | Присваивание |
| `==`   | Двойное равно | Сравнение на равенство |
| `!=`   | Восклицательный знак с равно | Сравнение на неравенство |
| `<`    | Меньше | Сравнение "меньше" |
| `>`    | Больше | Сравнение "больше" |
| `<=`   | Меньше или равно | Сравнение "меньше или равно" |
| `>=`   | Больше или равно | Сравнение "больше или равно" |
| `&&`   | Двойной амперсанд | Логическое И |
| `\|\|` | Двойная вертикальная черта | Логическое ИЛИ |
| `!`    | Восклицательный знак | Логическое НЕ |
| `,`    | Запятая | Разделитель в списках |
| `;`    | Точка с запятой | Завершитель инструкций |
| `:`    | Двоеточие | Разделитель в объявлениях типов |
| `{`    | Открывающая фигурная скобка | Начало блока |
| `}`    | Закрывающая фигурная скобка | Конец блока |
| `(`    | Открывающая круглая скобка | Группировка, вызов функции |
| `)`    | Закрывающая круглая скобка | Группировка, вызов функции |

## 5. Комментарии

Комментарии игнорируются на лексическом уровне и не влияют на синтаксический разбор.

| Тип | Синтаксис | Пример |
|-----|-----------|--------|
| Однострочный  | `//` до конца строки | `// это комментарий` |
| Многострочный | `/* ... */` | `/* многострочный\n комментарий */` |

Многострочные комментарии не вкладываются.

## 6. Полная EBNF-грамматика лексем

```ebnf
(* Базовые символы *)
digit        = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
hex_digit    = digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
binary_digit = "0" | "1" ;
letter       = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
        | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
        | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
        | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
whitespace = ? Unicode-символы пробела? ;

(* Идентификаторы и ключевые слова *)
identifier = (letter | "_"), { letter | digit | "_" } ;
keyword    = "fn" | "let" | "return" | "if" | "else" | "while" | "for"
        | "break" | "continue" | "int" | "float"
        | "str" | "unit" | "bool";

(* Литералы *)
bool_literal        = "true" | "false";
integer_literal     = decimal_literal | hexadecimal_literal | binary_literal ;
decimal_literal     = digit , { digit } ;
hexadecimal_literal = ("0x" | "0X") , hex_digit , { hex_digit } ;
binary_literal = ("0b" | "0B") , binary_digit , { binary_digit } ;

float_literal   = digit , { digit } , "." , digit , { digit } ;
string_literal  = '"' , { character | escape_sequence } , '"' ;
character       = ? любой Unicode-символ, кроме " и \ ? ;
escape_sequence = "\\" , ( "n" | "t" | "\\" | "\"" ) ;

(* Операторы и знаки пунктуации *)
operator = "+" | "-" | "*" | "/" | "%" | "**" | "="
         | "==" | "!=" | "<" | ">" | "<=" | ">="
         | "&&" | "||" | "!" ;
punctuation = "," | ";" | ":" | "{" | "}" | "(" | ")" ;

(* Комментарии *)
line_comment  = "//" , { ? любой символ, кроме конца строки ? } ;
block_comment = "/*" , { ? любой символ, кроме "*/" ? } , "*/" ;

(* Объединение всех лексем *)
lexeme = keyword | identifier | integer_literal | float_literal
       | bool_literal | string_literal | operator | punctuation | whitespace
       | line_comment | block_comment ;